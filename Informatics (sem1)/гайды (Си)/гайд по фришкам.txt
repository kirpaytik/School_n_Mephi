THE ULTIMATE GUIDE по фукнции free()
-----

1. Надо фришить в конце, конечно


2. Указатели, которые ты в функции ретурнаешь, фришить не надо, ведь память не теряется, а передаётся во внешний указатель, где функция была вызвана
Но, возможно, в таком случае надо фришнуть тот старый внешний указатель (частный случай - использование readline, это следующий пункт)
Но в то же время нужно фришнуть то, что в функции аллокалось, но не ретурнается, z.B:
char *s;
/* код, который как-то формирует строку s */
strcpy(*target, s); // копируем s во внешний указатель, а не ретурнаем, так что s нужно после этого фришнуть
free(s);


3. Также z.B есть char *x; и ты его x = readline();
Если ты его собираешься второй раз x = readline(), то перед этим надо его (икс) фришнуть,
иначе теряешь старый икс, ну а валгринд почему-то ругается на realloc внутри ридлайна (??)
Это там есть в лабе 5 в функции initializeList()


4. Если есть список, то надо фришнуть:
z.B есть список:
typedef struct Item {
    char *adr, *num;
    double sqr;
    struct Item *next;
} Item;
typedef struct List {
    Item *head;
} List;
1) проходишься по элементам и фришишь все поля, которые обычно надо фришить (то, что мы аллокали): free(ptr->adr); free(ptr->num);
2) фришишь сам элемент: free(ptr);
3) после того, как проделал это со всеми в цикле, фришишь сам список: free(list);
Этот пункт, короче, есть в лабе 5 в самом конце мэйна перед ретурном. Там пункты 1 и 2 сделал в своей отдельной функции freeList() только

5. В пятой лабе столкнулся с проблемой:
Есть Item *ptr = (Item*)malloc(sizeof(Item)), ptr->adr = (char*)malloc(len*sizeof(char)) и ptr->num = (char*)malloc(12*sizeof(char))
также имеется char *x = readl() и char *y, который считывается хитрым образом, но не суть, он тоже где-то под коробкой y = readl()
Так вот я копирую x в ptr->adr: strcpy(ptr->adr, x)
и затем фришу икс (чтобы при следующем ридле он был пустым, т.к там strcat идёт)
затем strcpy(ptr->num, y)
free(y)
НО! почему-то как-то всё вместе схлопывается, и после этого икс оказывается не пустым, а равным предыдущему значению строки, лежащей в y
В общем, там при free(x); free(y); икс и игрик помещаются в одну ячейку памяти типо, если я правильно понял (могу ошибаться, но чекал дебаг в online-gdb),
и там тудым-сюдым, ну и вот. А потом и в самом листе значения магическим образом меняются
Короче, я не понял, почему так, но у меня есть решение:
После free(x) написать x = NULL, также и после free(y); y = NULL;
Тогда они никак не будут указывать на одну область памяти, т.к они нулли. Просто после фришки занулить, т.к итак зафришили => значение не нужно больше => почему бы и не занулить

6. В первой лабе по АиСДу:
Есть матрица Matrix matr. Во freeMatr(&matr) я передаю адрес matr. Но т.к изначально указателя не сущ, то и free(matr) внутри freeMatr() писать не нужно!!

7. 1 лаба АиСД:
Есть матрица Matrix *matr, содержащая Array *ptr. Во freeMatr() надо очистить внутренности каждого Array, на массив которых указывает matr->ptr.
Но в matr мы храним указатель на массив Array'ев, но не сущ указателя на отдельный Array (мы лишь можем получить адрес путём arr = matr->ptr + i).
Поэтому free(arr) не нужно!!
